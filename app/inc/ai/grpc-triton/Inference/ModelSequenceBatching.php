<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: model_config.proto

namespace Inference;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\RepeatedField;
use Google\Protobuf\Internal\GPBUtil;

/**
 *&#64;&#64;
 *&#64;&#64;.. cpp:var:: message ModelSequenceBatching
 *&#64;&#64;
 *&#64;&#64;   Sequence batching configuration. These settings control how sequence
 *&#64;&#64;   batching operates for the model.
 *&#64;&#64;
 *
 * Generated from protobuf message <code>inference.ModelSequenceBatching</code>
 */
class ModelSequenceBatching extends \Google\Protobuf\Internal\Message
{
    /**
     *&#64;&#64;  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *&#64;&#64;
     *&#64;&#64;     The maximum time, in microseconds, that a sequence is allowed to
     *&#64;&#64;     be idle before it is aborted. The inference server considers a
     *&#64;&#64;     sequence idle when it does not have any inference request queued
     *&#64;&#64;     for the sequence. If this limit is exceeded, the inference server
     *&#64;&#64;     will free the sequence slot allocated by the sequence and make it
     *&#64;&#64;     available for another sequence. If not specified (or specified as
     *&#64;&#64;     zero) a default value of 1000000 (1 second) is used.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     */
    protected $max_sequence_idle_microseconds = 0;
    /**
     *&#64;&#64;  .. cpp:var:: ControlInput control_input (repeated)
     *&#64;&#64;
     *&#64;&#64;     The model input(s) that the server should use to communicate
     *&#64;&#64;     sequence start, stop, ready and similar control values to the
     *&#64;&#64;     model.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     */
    private $control_input;
    /**
     *&#64;&#64;  .. cpp:var:: State state (repeated)
     *&#64;&#64;
     *&#64;&#64;     The optional state that can be stored in Triton for performing
     *&#64;&#64;     inference requests on a sequence. Each sequence holds an implicit
     *&#64;&#64;     state local to itself. The output state tensor provided by the
     *&#64;&#64;     model in 'output_name' field of the current inference request will
     *&#64;&#64;     be transferred as an input tensor named 'input_name' in the next
     *&#64;&#64;     request of the same sequence. The input state of the first request
     *&#64;&#64;     in the sequence contains garbage data.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     */
    private $state;
    /**
     *&#64;&#64;  .. cpp:var:: bool iterative_sequence
     *&#64;&#64;
     *&#64;&#64;     Requests for iterative sequences are processed over a number
     *&#64;&#64;     of iterations. An iterative sequence is initiated by a single
     *&#64;&#64;     request and is "rescheduled" by the model until completion.
     *&#64;&#64;     Requests for inflight requests will be batched together
     *&#64;&#64;     and can complete independently. Note this feature
     *&#64;&#64;     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     */
    protected $iterative_sequence = false;
    protected $strategy_choice;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Inference\ModelSequenceBatching\StrategyDirect $direct
     *          &#64;&#64;    .. cpp:var:: StrategyDirect direct
     *          &#64;&#64;
     *          &#64;&#64;       StrategyDirect scheduling strategy.
     *          &#64;&#64;
     *     @type \Inference\ModelSequenceBatching\StrategyOldest $oldest
     *          &#64;&#64;    .. cpp:var:: StrategyOldest oldest
     *          &#64;&#64;
     *          &#64;&#64;       StrategyOldest scheduling strategy.
     *          &#64;&#64;
     *     @type int|string $max_sequence_idle_microseconds
     *          &#64;&#64;  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *          &#64;&#64;
     *          &#64;&#64;     The maximum time, in microseconds, that a sequence is allowed to
     *          &#64;&#64;     be idle before it is aborted. The inference server considers a
     *          &#64;&#64;     sequence idle when it does not have any inference request queued
     *          &#64;&#64;     for the sequence. If this limit is exceeded, the inference server
     *          &#64;&#64;     will free the sequence slot allocated by the sequence and make it
     *          &#64;&#64;     available for another sequence. If not specified (or specified as
     *          &#64;&#64;     zero) a default value of 1000000 (1 second) is used.
     *          &#64;&#64;
     *     @type \Inference\ModelSequenceBatching\ControlInput[]|\Google\Protobuf\Internal\RepeatedField $control_input
     *          &#64;&#64;  .. cpp:var:: ControlInput control_input (repeated)
     *          &#64;&#64;
     *          &#64;&#64;     The model input(s) that the server should use to communicate
     *          &#64;&#64;     sequence start, stop, ready and similar control values to the
     *          &#64;&#64;     model.
     *          &#64;&#64;
     *     @type \Inference\ModelSequenceBatching\State[]|\Google\Protobuf\Internal\RepeatedField $state
     *          &#64;&#64;  .. cpp:var:: State state (repeated)
     *          &#64;&#64;
     *          &#64;&#64;     The optional state that can be stored in Triton for performing
     *          &#64;&#64;     inference requests on a sequence. Each sequence holds an implicit
     *          &#64;&#64;     state local to itself. The output state tensor provided by the
     *          &#64;&#64;     model in 'output_name' field of the current inference request will
     *          &#64;&#64;     be transferred as an input tensor named 'input_name' in the next
     *          &#64;&#64;     request of the same sequence. The input state of the first request
     *          &#64;&#64;     in the sequence contains garbage data.
     *          &#64;&#64;
     *     @type bool $iterative_sequence
     *          &#64;&#64;  .. cpp:var:: bool iterative_sequence
     *          &#64;&#64;
     *          &#64;&#64;     Requests for iterative sequences are processed over a number
     *          &#64;&#64;     of iterations. An iterative sequence is initiated by a single
     *          &#64;&#64;     request and is "rescheduled" by the model until completion.
     *          &#64;&#64;     Requests for inflight requests will be batched together
     *          &#64;&#64;     and can complete independently. Note this feature
     *          &#64;&#64;     requires backend support. Default value is false.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ModelConfig::initOnce();
        parent::__construct($data);
    }

    /**
     *&#64;&#64;    .. cpp:var:: StrategyDirect direct
     *&#64;&#64;
     *&#64;&#64;       StrategyDirect scheduling strategy.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyDirect direct = 3;</code>
     * @return \Inference\ModelSequenceBatching\StrategyDirect
     */
    public function getDirect()
    {
        return $this->readOneof(3);
    }

    /**
     *&#64;&#64;    .. cpp:var:: StrategyDirect direct
     *&#64;&#64;
     *&#64;&#64;       StrategyDirect scheduling strategy.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyDirect direct = 3;</code>
     * @param \Inference\ModelSequenceBatching\StrategyDirect $var
     * @return $this
     */
    public function setDirect($var)
    {
        GPBUtil::checkMessage($var, \Inference\ModelSequenceBatching_StrategyDirect::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     *&#64;&#64;    .. cpp:var:: StrategyOldest oldest
     *&#64;&#64;
     *&#64;&#64;       StrategyOldest scheduling strategy.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyOldest oldest = 4;</code>
     * @return \Inference\ModelSequenceBatching\StrategyOldest
     */
    public function getOldest()
    {
        return $this->readOneof(4);
    }

    /**
     *&#64;&#64;    .. cpp:var:: StrategyOldest oldest
     *&#64;&#64;
     *&#64;&#64;       StrategyOldest scheduling strategy.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyOldest oldest = 4;</code>
     * @param \Inference\ModelSequenceBatching\StrategyOldest $var
     * @return $this
     */
    public function setOldest($var)
    {
        GPBUtil::checkMessage($var, \Inference\ModelSequenceBatching_StrategyOldest::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     *&#64;&#64;  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *&#64;&#64;
     *&#64;&#64;     The maximum time, in microseconds, that a sequence is allowed to
     *&#64;&#64;     be idle before it is aborted. The inference server considers a
     *&#64;&#64;     sequence idle when it does not have any inference request queued
     *&#64;&#64;     for the sequence. If this limit is exceeded, the inference server
     *&#64;&#64;     will free the sequence slot allocated by the sequence and make it
     *&#64;&#64;     available for another sequence. If not specified (or specified as
     *&#64;&#64;     zero) a default value of 1000000 (1 second) is used.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     * @return int|string
     */
    public function getMaxSequenceIdleMicroseconds()
    {
        return $this->max_sequence_idle_microseconds;
    }

    /**
     *&#64;&#64;  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *&#64;&#64;
     *&#64;&#64;     The maximum time, in microseconds, that a sequence is allowed to
     *&#64;&#64;     be idle before it is aborted. The inference server considers a
     *&#64;&#64;     sequence idle when it does not have any inference request queued
     *&#64;&#64;     for the sequence. If this limit is exceeded, the inference server
     *&#64;&#64;     will free the sequence slot allocated by the sequence and make it
     *&#64;&#64;     available for another sequence. If not specified (or specified as
     *&#64;&#64;     zero) a default value of 1000000 (1 second) is used.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxSequenceIdleMicroseconds($var)
    {
        GPBUtil::checkUint64($var);
        $this->max_sequence_idle_microseconds = $var;

        return $this;
    }

    /**
     *&#64;&#64;  .. cpp:var:: ControlInput control_input (repeated)
     *&#64;&#64;
     *&#64;&#64;     The model input(s) that the server should use to communicate
     *&#64;&#64;     sequence start, stop, ready and similar control values to the
     *&#64;&#64;     model.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getControlInput()
    {
        return $this->control_input;
    }

    /**
     *&#64;&#64;  .. cpp:var:: ControlInput control_input (repeated)
     *&#64;&#64;
     *&#64;&#64;     The model input(s) that the server should use to communicate
     *&#64;&#64;     sequence start, stop, ready and similar control values to the
     *&#64;&#64;     model.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     * @param \Inference\ModelSequenceBatching\ControlInput[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setControlInput($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Inference\ModelSequenceBatching\ControlInput::class);
        $this->control_input = $arr;

        return $this;
    }

    /**
     *&#64;&#64;  .. cpp:var:: State state (repeated)
     *&#64;&#64;
     *&#64;&#64;     The optional state that can be stored in Triton for performing
     *&#64;&#64;     inference requests on a sequence. Each sequence holds an implicit
     *&#64;&#64;     state local to itself. The output state tensor provided by the
     *&#64;&#64;     model in 'output_name' field of the current inference request will
     *&#64;&#64;     be transferred as an input tensor named 'input_name' in the next
     *&#64;&#64;     request of the same sequence. The input state of the first request
     *&#64;&#64;     in the sequence contains garbage data.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     * @return \Google\Protobuf\Internal\RepeatedField
     */
    public function getState()
    {
        return $this->state;
    }

    /**
     *&#64;&#64;  .. cpp:var:: State state (repeated)
     *&#64;&#64;
     *&#64;&#64;     The optional state that can be stored in Triton for performing
     *&#64;&#64;     inference requests on a sequence. Each sequence holds an implicit
     *&#64;&#64;     state local to itself. The output state tensor provided by the
     *&#64;&#64;     model in 'output_name' field of the current inference request will
     *&#64;&#64;     be transferred as an input tensor named 'input_name' in the next
     *&#64;&#64;     request of the same sequence. The input state of the first request
     *&#64;&#64;     in the sequence contains garbage data.
     *&#64;&#64;
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     * @param \Inference\ModelSequenceBatching\State[]|\Google\Protobuf\Internal\RepeatedField $var
     * @return $this
     */
    public function setState($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Inference\ModelSequenceBatching\State::class);
        $this->state = $arr;

        return $this;
    }

    /**
     *&#64;&#64;  .. cpp:var:: bool iterative_sequence
     *&#64;&#64;
     *&#64;&#64;     Requests for iterative sequences are processed over a number
     *&#64;&#64;     of iterations. An iterative sequence is initiated by a single
     *&#64;&#64;     request and is "rescheduled" by the model until completion.
     *&#64;&#64;     Requests for inflight requests will be batched together
     *&#64;&#64;     and can complete independently. Note this feature
     *&#64;&#64;     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     * @return bool
     */
    public function getIterativeSequence()
    {
        return $this->iterative_sequence;
    }

    /**
     *&#64;&#64;  .. cpp:var:: bool iterative_sequence
     *&#64;&#64;
     *&#64;&#64;     Requests for iterative sequences are processed over a number
     *&#64;&#64;     of iterations. An iterative sequence is initiated by a single
     *&#64;&#64;     request and is "rescheduled" by the model until completion.
     *&#64;&#64;     Requests for inflight requests will be batched together
     *&#64;&#64;     and can complete independently. Note this feature
     *&#64;&#64;     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     * @param bool $var
     * @return $this
     */
    public function setIterativeSequence($var)
    {
        GPBUtil::checkBool($var);
        $this->iterative_sequence = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getStrategyChoice()
    {
        return $this->whichOneof("strategy_choice");
    }

}

