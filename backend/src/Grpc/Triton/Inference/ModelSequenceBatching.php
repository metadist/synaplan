<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: model_config.proto

namespace Inference;

use Google\Protobuf\Internal\GPBType;
use Google\Protobuf\Internal\GPBUtil;
use Google\Protobuf\RepeatedField;

/**
 *\@\@
 *\@\@.. cpp:var:: message ModelSequenceBatching
 *\@\@
 *\@\@   Sequence batching configuration. These settings control how sequence
 *\@\@   batching operates for the model.
 *\@\@
 *
 * Generated from protobuf message <code>inference.ModelSequenceBatching</code>
 */
class ModelSequenceBatching extends \Google\Protobuf\Internal\Message
{
    /**
     *\@\@  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *\@\@
     *\@\@     The maximum time, in microseconds, that a sequence is allowed to
     *\@\@     be idle before it is aborted. The inference server considers a
     *\@\@     sequence idle when it does not have any inference request queued
     *\@\@     for the sequence. If this limit is exceeded, the inference server
     *\@\@     will free the sequence slot allocated by the sequence and make it
     *\@\@     available for another sequence. If not specified (or specified as
     *\@\@     zero) a default value of 1000000 (1 second) is used.
     *\@\@
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     */
    protected $max_sequence_idle_microseconds = 0;
    /**
     *\@\@  .. cpp:var:: ControlInput control_input (repeated)
     *\@\@
     *\@\@     The model input(s) that the server should use to communicate
     *\@\@     sequence start, stop, ready and similar control values to the
     *\@\@     model.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     */
    private $control_input;
    /**
     *\@\@  .. cpp:var:: State state (repeated)
     *\@\@
     *\@\@     The optional state that can be stored in Triton for performing
     *\@\@     inference requests on a sequence. Each sequence holds an implicit
     *\@\@     state local to itself. The output state tensor provided by the
     *\@\@     model in 'output_name' field of the current inference request will
     *\@\@     be transferred as an input tensor named 'input_name' in the next
     *\@\@     request of the same sequence. The input state of the first request
     *\@\@     in the sequence contains garbage data.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     */
    private $state;
    /**
     *\@\@  .. cpp:var:: bool iterative_sequence
     *\@\@
     *\@\@     Requests for iterative sequences are processed over a number
     *\@\@     of iterations. An iterative sequence is initiated by a single
     *\@\@     request and is "rescheduled" by the model until completion.
     *\@\@     Requests for inflight requests will be batched together
     *\@\@     and can complete independently. Note this feature
     *\@\@     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     */
    protected $iterative_sequence = false;
    protected $strategy_choice;

    /**
     * Constructor.
     *
     * @param array $data {
     *     Optional. Data for populating the Message object.
     *
     *     @type \Inference\ModelSequenceBatching\StrategyDirect $direct
     *          \@\@    .. cpp:var:: StrategyDirect direct
     *          \@\@
     *          \@\@       StrategyDirect scheduling strategy.
     *          \@\@
     *     @type \Inference\ModelSequenceBatching\StrategyOldest $oldest
     *          \@\@    .. cpp:var:: StrategyOldest oldest
     *          \@\@
     *          \@\@       StrategyOldest scheduling strategy.
     *          \@\@
     *     @type int|string $max_sequence_idle_microseconds
     *          \@\@  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *          \@\@
     *          \@\@     The maximum time, in microseconds, that a sequence is allowed to
     *          \@\@     be idle before it is aborted. The inference server considers a
     *          \@\@     sequence idle when it does not have any inference request queued
     *          \@\@     for the sequence. If this limit is exceeded, the inference server
     *          \@\@     will free the sequence slot allocated by the sequence and make it
     *          \@\@     available for another sequence. If not specified (or specified as
     *          \@\@     zero) a default value of 1000000 (1 second) is used.
     *          \@\@
     *     @type \Inference\ModelSequenceBatching\ControlInput[] $control_input
     *          \@\@  .. cpp:var:: ControlInput control_input (repeated)
     *          \@\@
     *          \@\@     The model input(s) that the server should use to communicate
     *          \@\@     sequence start, stop, ready and similar control values to the
     *          \@\@     model.
     *          \@\@
     *     @type \Inference\ModelSequenceBatching\State[] $state
     *          \@\@  .. cpp:var:: State state (repeated)
     *          \@\@
     *          \@\@     The optional state that can be stored in Triton for performing
     *          \@\@     inference requests on a sequence. Each sequence holds an implicit
     *          \@\@     state local to itself. The output state tensor provided by the
     *          \@\@     model in 'output_name' field of the current inference request will
     *          \@\@     be transferred as an input tensor named 'input_name' in the next
     *          \@\@     request of the same sequence. The input state of the first request
     *          \@\@     in the sequence contains garbage data.
     *          \@\@
     *     @type bool $iterative_sequence
     *          \@\@  .. cpp:var:: bool iterative_sequence
     *          \@\@
     *          \@\@     Requests for iterative sequences are processed over a number
     *          \@\@     of iterations. An iterative sequence is initiated by a single
     *          \@\@     request and is "rescheduled" by the model until completion.
     *          \@\@     Requests for inflight requests will be batched together
     *          \@\@     and can complete independently. Note this feature
     *          \@\@     requires backend support. Default value is false.
     * }
     */
    public function __construct($data = NULL) {
        \GPBMetadata\ModelConfig::initOnce();
        parent::__construct($data);
    }

    /**
     *\@\@    .. cpp:var:: StrategyDirect direct
     *\@\@
     *\@\@       StrategyDirect scheduling strategy.
     *\@\@
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyDirect direct = 3;</code>
     * @return \Inference\ModelSequenceBatching\StrategyDirect|null
     */
    public function getDirect()
    {
        return $this->readOneof(3);
    }

    public function hasDirect()
    {
        return $this->hasOneof(3);
    }

    /**
     *\@\@    .. cpp:var:: StrategyDirect direct
     *\@\@
     *\@\@       StrategyDirect scheduling strategy.
     *\@\@
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyDirect direct = 3;</code>
     * @param \Inference\ModelSequenceBatching\StrategyDirect $var
     * @return $this
     */
    public function setDirect($var)
    {
        GPBUtil::checkMessage($var, \Inference\ModelSequenceBatching\StrategyDirect::class);
        $this->writeOneof(3, $var);

        return $this;
    }

    /**
     *\@\@    .. cpp:var:: StrategyOldest oldest
     *\@\@
     *\@\@       StrategyOldest scheduling strategy.
     *\@\@
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyOldest oldest = 4;</code>
     * @return \Inference\ModelSequenceBatching\StrategyOldest|null
     */
    public function getOldest()
    {
        return $this->readOneof(4);
    }

    public function hasOldest()
    {
        return $this->hasOneof(4);
    }

    /**
     *\@\@    .. cpp:var:: StrategyOldest oldest
     *\@\@
     *\@\@       StrategyOldest scheduling strategy.
     *\@\@
     *
     * Generated from protobuf field <code>.inference.ModelSequenceBatching.StrategyOldest oldest = 4;</code>
     * @param \Inference\ModelSequenceBatching\StrategyOldest $var
     * @return $this
     */
    public function setOldest($var)
    {
        GPBUtil::checkMessage($var, \Inference\ModelSequenceBatching\StrategyOldest::class);
        $this->writeOneof(4, $var);

        return $this;
    }

    /**
     *\@\@  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *\@\@
     *\@\@     The maximum time, in microseconds, that a sequence is allowed to
     *\@\@     be idle before it is aborted. The inference server considers a
     *\@\@     sequence idle when it does not have any inference request queued
     *\@\@     for the sequence. If this limit is exceeded, the inference server
     *\@\@     will free the sequence slot allocated by the sequence and make it
     *\@\@     available for another sequence. If not specified (or specified as
     *\@\@     zero) a default value of 1000000 (1 second) is used.
     *\@\@
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     * @return int|string
     */
    public function getMaxSequenceIdleMicroseconds()
    {
        return $this->max_sequence_idle_microseconds;
    }

    /**
     *\@\@  .. cpp:var:: uint64 max_sequence_idle_microseconds
     *\@\@
     *\@\@     The maximum time, in microseconds, that a sequence is allowed to
     *\@\@     be idle before it is aborted. The inference server considers a
     *\@\@     sequence idle when it does not have any inference request queued
     *\@\@     for the sequence. If this limit is exceeded, the inference server
     *\@\@     will free the sequence slot allocated by the sequence and make it
     *\@\@     available for another sequence. If not specified (or specified as
     *\@\@     zero) a default value of 1000000 (1 second) is used.
     *\@\@
     *
     * Generated from protobuf field <code>uint64 max_sequence_idle_microseconds = 1;</code>
     * @param int|string $var
     * @return $this
     */
    public function setMaxSequenceIdleMicroseconds($var)
    {
        GPBUtil::checkUint64($var);
        $this->max_sequence_idle_microseconds = $var;

        return $this;
    }

    /**
     *\@\@  .. cpp:var:: ControlInput control_input (repeated)
     *\@\@
     *\@\@     The model input(s) that the server should use to communicate
     *\@\@     sequence start, stop, ready and similar control values to the
     *\@\@     model.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     * @return RepeatedField<\Inference\ModelSequenceBatching\ControlInput>
     */
    public function getControlInput()
    {
        return $this->control_input;
    }

    /**
     *\@\@  .. cpp:var:: ControlInput control_input (repeated)
     *\@\@
     *\@\@     The model input(s) that the server should use to communicate
     *\@\@     sequence start, stop, ready and similar control values to the
     *\@\@     model.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.ControlInput control_input = 2;</code>
     * @param \Inference\ModelSequenceBatching\ControlInput[] $var
     * @return $this
     */
    public function setControlInput($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Inference\ModelSequenceBatching\ControlInput::class);
        $this->control_input = $arr;

        return $this;
    }

    /**
     *\@\@  .. cpp:var:: State state (repeated)
     *\@\@
     *\@\@     The optional state that can be stored in Triton for performing
     *\@\@     inference requests on a sequence. Each sequence holds an implicit
     *\@\@     state local to itself. The output state tensor provided by the
     *\@\@     model in 'output_name' field of the current inference request will
     *\@\@     be transferred as an input tensor named 'input_name' in the next
     *\@\@     request of the same sequence. The input state of the first request
     *\@\@     in the sequence contains garbage data.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     * @return RepeatedField<\Inference\ModelSequenceBatching\State>
     */
    public function getState()
    {
        return $this->state;
    }

    /**
     *\@\@  .. cpp:var:: State state (repeated)
     *\@\@
     *\@\@     The optional state that can be stored in Triton for performing
     *\@\@     inference requests on a sequence. Each sequence holds an implicit
     *\@\@     state local to itself. The output state tensor provided by the
     *\@\@     model in 'output_name' field of the current inference request will
     *\@\@     be transferred as an input tensor named 'input_name' in the next
     *\@\@     request of the same sequence. The input state of the first request
     *\@\@     in the sequence contains garbage data.
     *\@\@
     *
     * Generated from protobuf field <code>repeated .inference.ModelSequenceBatching.State state = 5;</code>
     * @param \Inference\ModelSequenceBatching\State[] $var
     * @return $this
     */
    public function setState($var)
    {
        $arr = GPBUtil::checkRepeatedField($var, \Google\Protobuf\Internal\GPBType::MESSAGE, \Inference\ModelSequenceBatching\State::class);
        $this->state = $arr;

        return $this;
    }

    /**
     *\@\@  .. cpp:var:: bool iterative_sequence
     *\@\@
     *\@\@     Requests for iterative sequences are processed over a number
     *\@\@     of iterations. An iterative sequence is initiated by a single
     *\@\@     request and is "rescheduled" by the model until completion.
     *\@\@     Requests for inflight requests will be batched together
     *\@\@     and can complete independently. Note this feature
     *\@\@     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     * @return bool
     */
    public function getIterativeSequence()
    {
        return $this->iterative_sequence;
    }

    /**
     *\@\@  .. cpp:var:: bool iterative_sequence
     *\@\@
     *\@\@     Requests for iterative sequences are processed over a number
     *\@\@     of iterations. An iterative sequence is initiated by a single
     *\@\@     request and is "rescheduled" by the model until completion.
     *\@\@     Requests for inflight requests will be batched together
     *\@\@     and can complete independently. Note this feature
     *\@\@     requires backend support. Default value is false.
     *
     * Generated from protobuf field <code>bool iterative_sequence = 6;</code>
     * @param bool $var
     * @return $this
     */
    public function setIterativeSequence($var)
    {
        GPBUtil::checkBool($var);
        $this->iterative_sequence = $var;

        return $this;
    }

    /**
     * @return string
     */
    public function getStrategyChoice()
    {
        return $this->whichOneof("strategy_choice");
    }

}

